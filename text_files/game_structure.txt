### 1. Initial Application Load and Puzzle Selection

*   **`cryptic_crossword.html` (Initial State):** When the page first loads, the `level-selection-container` is visible, displaying an `<h1>Select a Puzzle</h1>` heading and an empty `div` with `id="puzzle-list"`. The main `game-wrapper` (containing the crossword grid and clues) is initially hidden via `style="display:none;"`.
*   **`script.js` (DOMContentLoaded & `showLevelSelector`):**
    *   Upon the browser's `DOMContentLoaded` event, the `showLevelSelector()` function is called.
    *   `showLevelSelector()` initiates a `fetch` request to `puzzles.json`. This file acts as a manifest, listing available crossword puzzles.
    *   Once `puzzles.json` is successfully fetched and parsed, `script.js` iterates through the array of puzzle objects. For each puzzle (e.g., "easy_1", "medium_1"), it dynamically creates a `<button>` element.
    *   The `textContent` of each button is set to the puzzle's `title` and `difficulty` (e.g., "A Quick Start (Easy)").
    *   Crucially, an `onclick` event listener is attached to each button, configured to call the `loadPuzzle()` function, passing the `file` path of the specific puzzle (e.g., `"puzzles/easy_1.json"`).
    *   These generated buttons are then appended to the `puzzle-list` div in the HTML, making them visible to the user.

### 2. Loading a Specific Puzzle

*   **`script.js` (`loadPuzzle` function):**
    *   When a user clicks one of the puzzle selection buttons, the `loadPuzzle(puzzleFile)` function is executed with the path to the selected puzzle's JSON data.
    *   `loadPuzzle()` performs another `fetch` request, this time to the specific `puzzleFile` (e.g., `puzzles/easy_1.json`).
    *   Upon successful retrieval and parsing of the puzzle data (which includes `size`, `gridSpec`, and `clues`), the UI transitions:
        *   The `level-selection-container`'s `display` style is set to `none`, hiding the puzzle selection screen.
        *   The `game-wrapper`'s `display` style is set to `flex`, making the main crossword game interface visible.
    *   **Clearing Previous Game State:** Before initializing a new game, the `innerHTML` of `grid-container`, `across-clues`, and `down-clues` are explicitly cleared. This ensures that any elements from a previously loaded puzzle are removed, preventing visual artifacts or incorrect state.
    *   **`CrosswordGame` Instantiation:** A new instance of the `CrosswordGame` class is created, passing the fetched `puzzleData` to its constructor.
    *   **Game Initialization:** The `init()` method of the newly created `CrosswordGame` instance is called, which triggers the core setup of the crossword.

### 3. Game Initialization (`CrosswordGame` Class)

The `CrosswordGame` class handles all the logic for a single crossword puzzle.

*   **`constructor(puzzleData)`:** Initializes properties like `this.puzzleData`, empty arrays for `gridCells`, default `currentDirection` ('across'), and references to key DOM elements. It also sets up `cellClueMapping` (to quickly find clues associated with a cell) and `clueCellMapping` (to find cells associated with a clue).
*   **`init()` Method:** This is the orchestrator for setting up the game:
    *   **`generateSolution()`:** This method processes the `clues` data (both `across` and `down`) from `puzzleData`. It constructs a flat array, `this.puzzleData.solution`, where each element corresponds to a cell in the grid and holds the correct letter for that cell. This array is used later for checking answers.
    *   **`buildClueMappings()`:** This populates `cellClueMapping` and `clueCellMapping`. For every cell in the grid, `cellClueMapping` stores references to the `across` and `down` clue objects it belongs to. Conversely, `clueCellMapping` stores arrays of cell indices for each clue number, making it easy to highlight all cells for a given clue.
    *   **`renderGrid()`:**
        *   It dynamically sets a CSS variable `--grid-size` on the `document.documentElement` based on `this.puzzleData.size`. This allows `style.css` to adjust the grid layout using `grid-template-columns` and `grid-template-rows`.
        *   It iterates through `puzzleData.gridSpec` (which defines each cell's properties like `x`, `y`, `number`, `black`).
        *   For each cell, it creates a `div.grid-cell`.
        *   If `cellSpec.black` is true, the cell gets the `black` class (styled as an unplayable black square).
        *   Otherwise, an `<input type="text" maxLength="1">` element is created and appended to the cell. This input is where the user types letters.
        *   If `cellSpec.number` exists, a `span.number` is added to the cell to display the clue number.
        *   ARIA attributes (`role="gridcell"`, `aria-label`) are added to the cells and inputs for accessibility.
        *   All generated cells are appended to the `grid-container`.
    *   **`renderClues()`:**
        *   This method iterates through `puzzleData.clues.across` and `puzzleData.clues.down`.
        *   For each clue, it creates an `<li>` element, setting its `textContent` (e.g., "1. A large bird...") and a `data-clue` attribute (e.g., "across1").
        *   A `click` event listener is added to each `<li>`. When a clue is clicked, it sets the `currentDirection` to 'across' or 'down', calls `highlightClue()` for that specific clue, and then programmatically focuses the input field of the first cell associated with that clue.
        *   These generated buttons are then appended to the `puzzle-list` div in the HTML, making them visible to the user.
        *   These `<li>` elements are appended to `across-clues` and `down-clues` `<ul>` elements.
    *   **`addEventListeners()`:** This centralizes all event listeners for user interaction:
        *   **`check-button`:** Listens for clicks to trigger `checkPuzzle()`.
        *   **`gridContainer` (mousedown):** If a user clicks on an input cell that is already the `activeCellIndex`, and that cell is part of both an across and a down clue, it toggles the `currentDirection` (`across` to `down` or vice-versa) and re-highlights the appropriate clue.
        *   **`gridContainer` (keyup):** This is crucial for input and navigation:
            *   **Arrow Keys:** `ArrowRight`, `ArrowLeft`, `ArrowDown`, `ArrowUp` move focus to the next/previous cell in the corresponding direction, updating `currentDirection`.
            *   **Backspace:** Clears the current cell's input and moves focus to the previous cell in the `currentDirection`.
            *   **Letter Input:** If a single letter is typed, it automatically advances focus to the next cell in the `currentDirection`.
            *   After any key event that changes focus, `handleFocus()` is called for the new cell.
        *   **`gridContainer` (focusin):** When an input cell gains focus, `handleFocus()` is called to update the active cell and highlighting.
        *   **Modal Close Button:** Listens for clicks to hide the `win-modal`.

### 4. User Interaction and Highlighting

*   **`handleFocus(index)`:**
    *   This function is called whenever an input cell gains focus (either by clicking or keyboard navigation).
    *   It updates `this.activeCellIndex`.
    *   It retrieves the `clues` associated with the `index` from `cellClueMapping`.
    *   Based on whether the cell has `across`, `down`, or both types of clues, it determines the `currentDirection` and calls `highlightClue()` for the relevant clue.
    *   It also calls `highlightCurrentClues()` to ensure both the across and down clues in the clue list are highlighted if the cell is part of both.
*   **`highlightClue(clue, dir)`:**
    *   Removes the `highlighted` class from all previously highlighted grid cells and the `active` class from all clue list items.
    *   If a `clue` object is provided, it retrieves the `cellsToHighlight` (an array of cell indices) from `clueCellMapping` for the given `dir` and `clue.number`.
    *   It then adds the `highlighted` class to each of these grid cells, visually indicating the active word.
    *   Finally, it adds the `active` class to the corresponding `<li>` element in the clue list.
*   **`highlightCurrentClues(cellIndex)`:**
    *   This function ensures that both the across and down clues in the clue list are highlighted if the `cellIndex` is part of both. It removes existing `active` classes from clue list items and then adds the `active` class to the relevant across and/or down clue `<li>` elements.

### 5. Checking the Puzzle and Winning

*   **`checkPuzzle()`:**
    *   This function is triggered when the "Check Puzzle" button is clicked.
    *   It iterates through all `<input>` elements within the `gridContainer`.
    *   For each input, it compares the `input.value.toUpperCase()` with the corresponding correct letter stored in `this.puzzleData.solution[index]`.
    *   It removes any existing `correct` or `incorrect` classes.
    *   If the input is empty, it's considered incorrect.
    *   If the input matches the solution, the `correct` class is added to the input; otherwise, the `incorrect` class is added.
    *   A boolean flag `allCorrect` tracks if every cell is correct.
    *   **Win Condition:** If `allCorrect` remains `true` after checking all inputs, the `win-modal` (initially hidden in `cryptic_crossword.html`) is displayed by setting its `display` style to `block`. This modal congratulates the user.

### 6. Styling (`style.css`)

*   `style.css` provides all the visual presentation for the game. It defines:
    *   Layouts for the main containers (`body`, `#game-container`, `#clues-container`).
    *   Grid styling (`#grid-container`, `.grid-cell`), including dynamic sizing using CSS variables set by JavaScript.
    *   Input field styling, including focus and highlight states.
    *   Styles for black cells, clue numbers, and clue lists.
    *   Visual feedback for correct (`.correct`) and incorrect (`.incorrect`) answers.
    *   Styling for the "Check Puzzle" button and the win modal.
    *   Basic responsiveness for smaller screens using media queries.